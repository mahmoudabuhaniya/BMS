{% extends 'myproject/base.html' %}
{% load static %}

{% block content %}

<!-- Messages -->
{% if messages %}
  {% for message in messages %}
    <div class="alert alert-success alert-dismissible fade show shadow-sm rounded-3" role="alert">
      <i class="fas fa-check-circle me-2"></i> {{ message }}
      <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
    </div>
  {% endfor %}
{% endif %}

<div class="container py-5">

  <!-- Page Header -->
  <div class="d-flex justify-content-between align-items-center mb-4">
    <h2 class="fw-bold text-primary">
      <i class="fas fa-database me-2 text-primary"></i> Beneficiary Database
    </h2>
    <a href="{% url 'home' %}" class="btn btn-dark btn-sm">
      <i class="fas fa-home me-1"></i> Back to Home
    </a>
  </div>

  <!-- Filters -->
  <div class="card shadow-sm border-0 rounded-4 mb-4 p-3 alert alert-info">
    <div class="row g-3 align-items-start">

      <div class="col-12 mb-2">
        <label for="filter-operator" class="form-label fw-semibold">Combine Filters With:</label>
        <select id="filter-operator" class="form-select form-select-sm w-auto">
          <option value="AND" selected>AND</option>
          <option value="OR">OR</option>
        </select>
      </div>


      {% for field, label in filter_fields %}
        <div class="col-sm-6 col-md-3 position-relative">
          
          {% comment %}
            If field name contains 'date' (case-insensitive) we render a native date input
            which provides a calendar picker in modern browsers.
          {% endcomment %}
          {% if 'date' in field|lower %}
            <input
              type="date"
              class="form-control filter-input date-input"
              placeholder="Search {{ label }}"
              data-field="{{ field }}"
              autocomplete="off"
            >
          {% else %}
            <input
              color: black;
              background-color: white;
              type="text"
              class="form-control filter-input autocomplete-input"
              placeholder="Search {{ label }}"
              data-field="{{ field }}"
              autocomplete="on"
              list="list-{{ field }}"
            >
            <datalist id="list-{{ field }}"></datalist>

            <!-- autocomplete suggestions container -->
            <div class="autocomplete-menu position-absolute bg-white border rounded d-none"
                 style="z-index:1050; max-height:240px; overflow:auto; width:100%; top: calc(100% + 6px); color: black;">
            </div>
          {% endif %}

          <!-- small clear button (appears when input has value) -->
          <button type="button"
                  class="btn btn-sm btn-light position-absolute top-50 end-0 translate-middle-y me-2 d-none clear-btn"
                  aria-label="Clear field">
            <i class="fas fa-times"></i>
          </button>
        </div>
      {% endfor %}

    </div>

    <!-- Clear All Filters -->
    <div class="mt-3 text-end">
      <button id="clearAll" class="btn btn-danger btn-sm">
        <i class="fas fa-times-circle me-1"></i> Clear All Filters
      </button>
    </div>
  </div>

  <!-- Table + Pagination Container -->
  <div id="table-container" class="card shadow-lg border-0 rounded-4">
    <div class="card-body p-0">
      {% include 'myproject/inform_table.html' %}
    </div>
  </div>
</div>

<!-- Confirm Delete Modal (kept as-is) -->
<div class="modal" id="confirmModal" tabindex="-1" aria-labelledby="confirmModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content border-0 shadow-lg">
      <div class="modal-header bg-danger text-white">
        <h5 class="modal-title" id="confirmModalLabel">
          <i class="fas fa-exclamation-triangle me-2"></i> Confirm Deletion
        </h5>
        <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>

      <form id="deleteForm" method="POST" novalidate>
        {% csrf_token %}
        <input type="hidden" id="delete_pk" name="pk" />
        <div class="modal-body text-dark">
          <p class="fw-semibold mb-3">Are you sure you want to delete this record?</p>

          <div class="form-check mb-2">
            <input hidden class="form-check-input" type="radio" name="delete_option" id="delete_local" value="local" checked>
            <label hidden class="form-check-label" for="delete_local">Delete locally only</label>
          </div>

          <div class="form-check">
            <input hidden class="form-check-input" type="radio" name="delete_option" id="delete_both" value="both">
            <label hidden class="form-check-label" for="delete_both">Delete locally and from source</label>
          </div>
        </div>

        <div class="modal-footer">
          <button type="button" class="btn btn-secondary px-4" data-bs-dismiss="modal">Cancel</button>
          <button type="submit" class="btn btn-danger px-4 fw-bold">Delete</button>
        </div>
      </form>
    </div>
  </div>
</div>

<!-- Scripts: autocomplete + live filtering + date handling -->
<script>
/*
  Requirements:
  - The template expects a URL named 'autocomplete' that returns JSON array of strings:
      /autocomplete/?field=FIELD&q=QUERY
    If you don't have it, create a view that returns a JSON list of suggestions.
*/

(function () {
  const tableContainer = document.getElementById('table-container');
  const clearAllBtn = document.getElementById('clearAll');
  const debounceDelay = 300; // ms

  // helper debounce
  function debounce(fn, delay) {
    let t;
    return function (...args) {
      clearTimeout(t);
      t = setTimeout(() => fn.apply(this, args), delay);
    };
  }

  // Build query string from current filters
  function buildQuery() {
    const params = new URLSearchParams();

    // Add operator first
    const operator = document.getElementById('filter-operator').value || 'AND';
    params.set('operator', operator);

    // Add all filter fields
    document.querySelectorAll('.filter-input').forEach(el => {
      const v = el.value && el.value.toString().trim();
      if (v) params.append(el.dataset.field, v);
    });

    return params.toString();
  }

  // Replace table container with filtered HTML returned from server
  function applyFilters() {
    const q = buildQuery();
    const url = "{% url 'inform_data' %}" + (q ? '?' + q : '');
    fetch(url, { headers: { 'X-Requested-With': 'XMLHttpRequest' } })
      .then(r => {
        if (!r.ok) throw new Error('Network response not ok');
        return r.text();
      })
      .then(html => {
        tableContainer.innerHTML = html;
        // After DOM replaced, nothing else needed: filters live on main page.
      })
      .catch(err => {
        console.error('Filter request failed', err);
      });
  }

  const applyFiltersDebounced = debounce(applyFilters, debounceDelay);

  // Show/hide clear button for an input
  function toggleClearBtn(input) {
    const btn = input.parentElement.querySelector('.clear-btn');
    if (!btn) return;
    if (input.value && input.value.toString().trim() !== '') btn.classList.remove('d-none');
    else btn.classList.add('d-none');
  }

  // AUTOCOMPLETE: fetch suggestions from server
  async function fetchSuggestions(field, q) {
    try {
      const url = new URL("{% url 'autocomplete' %}", window.location.origin);
      url.searchParams.set('field', field);
      url.searchParams.set('q', q);
      const res = await fetch(url.toString(), { headers: { 'X-Requested-With': 'XMLHttpRequest' } });
      if (!res.ok) return [];
      const json = await res.json();
      if (!Array.isArray(json)) return [];
      return json;
    } catch (e) {
      // silence network errors (graceful degradation)
      console.warn('Autocomplete fetch failed', e);
      return [];
    }
  }

  // Build suggestion item element
  function makeSuggestionEl(text) {
    const div = document.createElement('div');
    div.className = 'px-2 py-2 autocomplete-item';
    div.style.cursor = 'pointer';
    div.textContent = text === null || text === undefined ? '' : text;
    return div;
  }

  // Close all autocomplete menus
  function closeAllMenus() {
    document.querySelectorAll('.autocomplete-menu').forEach(m => m.classList.add('d-none'));
  }

  // Setup handlers for each filter input
  document.querySelectorAll('.filter-input').forEach((input) => {
    // toggle clear button initially
    toggleClearBtn(input);

    // find clear button and menu (menu exists only for non-date/autocomplete inputs)
    const clearBtn = input.parentElement.querySelector('.clear-btn');
    const menu = input.parentElement.querySelector('.autocomplete-menu');

    // Input handler for all inputs (date or text)
    if (input.classList.contains('date-input')) {
      // DATE: native picker, listen to 'change'
      input.addEventListener('change', () => {
        toggleClearBtn(input);
        applyFilters(); // immediate apply (no debounce)
      });
    } else {
      // TEXT / AUTOCOMPLETE
      // keydown handlers for keyboard navigation inside menu
      input.addEventListener('keydown', (ev) => {
        if (!menu || menu.classList.contains('d-none')) return;
        const items = Array.from(menu.querySelectorAll('.autocomplete-item'));
        if (items.length === 0) return;

        const active = menu.querySelector('.active');
        let idx = items.indexOf(active);
        if (ev.key === 'ArrowDown') {
          ev.preventDefault();
          if (idx < items.length - 1) {
            if (active) active.classList.remove('active');
            items[idx + 1].classList.add('active');
            items[idx + 1].scrollIntoView({ block: 'nearest' });
          } else if (idx === -1) {
            items[0].classList.add('active');
            items[0].scrollIntoView({ block: 'nearest' });
          }
        } else if (ev.key === 'ArrowUp') {
          ev.preventDefault();
          if (idx > 0) {
            active.classList.remove('active');
            items[idx - 1].classList.add('active');
            items[idx - 1].scrollIntoView({ block: 'nearest' });
          }
        } else if (ev.key === 'Enter') {
          if (active) {
            ev.preventDefault();
            input.value = active.textContent;
            closeAllMenus();
            toggleClearBtn(input);
            applyFilters();
          }
        } else if (ev.key === 'Escape') {
          closeAllMenus();
        }
      });

      // main input -> fetch suggestions + live filter (debounced)
      input.addEventListener('input', debounce(async () => {
        const q = input.value && input.value.toString().trim();
        toggleClearBtn(input);

        // if empty show full table (or we let applyFilters handle it)
        if (!q) {
          closeAllMenus();
          applyFiltersDebounced();
          return;
        }

        // fetch suggestions
        const suggestions = await fetchSuggestions(input.dataset.field, q);
        if (!menu) return;
        menu.innerHTML = '';

        if (!suggestions || suggestions.length === 0) {
          menu.classList.add('d-none');
        } else {
          suggestions.forEach(s => {
            const el = makeSuggestionEl(s);
            el.addEventListener('click', () => {
              input.value = s;
              toggleClearBtn(input);
              closeAllMenus();
              applyFilters(); // immediate apply when selecting suggestion
            });
            menu.appendChild(el);
          });

          // remove top/bottom border duplication
          menu.classList.remove('d-none');
        }

        // live filter while typing (still debounced)
        applyFiltersDebounced();

      }, 300 )); // NOTE: Django will render literal 300 here but we already have debounceDelay variable

    } // end text/autocomplete handling

    // clear button click (works for both date and text)
    if (clearBtn) {
      clearBtn.addEventListener('click', () => {
        input.value = '';
        toggleClearBtn(input);
        closeAllMenus();
        applyFilters();
      });
    }
  });

  // Click outside to close menus
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.position-relative')) {
      closeAllMenus();
    }
  });

  // Clear all filters
  clearAllBtn.addEventListener('click', () => {
    document.querySelectorAll('.filter-input').forEach(i => {
      i.value = '';
      toggleClearBtn(i);
    });
    closeAllMenus();
    applyFilters();
  });

  // initial: attach apply on page load if querystring present (so table updates if page loaded with filters)
  window.addEventListener('load', () => {
    // show clear buttons for any pre-filled inputs (if you pre-fill them server-side later)
    document.querySelectorAll('.filter-input').forEach(i => toggleClearBtn(i));
  });

})();
</script>

<!-- tiny styles to help suggestion hover/active states -->
<style>
  .autocomplete-menu .autocomplete-item:hover { background: #f8f9fa; }
  .autocomplete-menu .autocomplete-item.active { background: #e9f5ff; }
  .filter-input.border-primary { box-shadow: 0 0 0 0.15rem rgba(0,123,255,0.12); border-color: #0d6efd !important; }
  .clear-btn { font-size: 0.85rem; padding: 0.25rem 0.45rem; }
</style>

{% endblock %}
